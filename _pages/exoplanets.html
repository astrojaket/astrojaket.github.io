---
layout: default
title: Exoplanets
permalink: /exoplanets
---

<!-- Exoplanet Explorer (Local CSVs, JWST/HST highlights, robust matching) -->
<div id="exo-explorer" class="exo-container">
  <div class="exo-topbar">
    <div class="exo-controls">
      <div class="exo-card">
        <h2>Axes</h2>
        <div class="exo-grid2">
          <label>X axis
            <select id="xSelect" class="exo-input"></select>
          </label>
          <label>Y axis
            <select id="ySelect" class="exo-input"></select>
          </label>
          <label class="exo-check"><input id="xLog" type="checkbox"/> Log X</label>
          <label class="exo-check"><input id="yLog" type="checkbox"/> Log Y</label>
          <label class="exo-check"><input id="colorTemp" type="checkbox"/> Color by Teq (K)</label>
          <label class="exo-check"><input id="showLabels" type="checkbox"/> Show labels (all)</label>
          <label class="exo-check"><input id="onlyTransiting" type="checkbox"/> Only transiting</label>
          <label class="exo-check"><input id="ckPredict" type="checkbox"> Use Chen &amp; Kipping (2017) mass when missing</label>
        </div>
      </div>

      <div class="exo-card">
        <h2>Filters (set limits then press Update)</h2>
        <div class="exo-grid4 exo-filters">
          <div><div class="exo-filter-label">Best Mass (M⊕)</div>
            <input id="f-min-pl_bmasse" class="exo-input" type="number" step="any" placeholder="min" />
            <input id="f-max-pl_bmasse" class="exo-input" type="number" step="any" placeholder="max" />
          </div>
          <div><div class="exo-filter-label">Best Mass (MJ)</div>
            <input id="f-min-pl_bmassj" class="exo-input" type="number" step="any" placeholder="min" />
            <input id="f-max-pl_bmassj" class="exo-input" type="number" step="any" placeholder="max" />
          </div>
          <div><div class="exo-filter-label">Radius (R⊕)</div>
            <input id="f-min-pl_rade" class="exo-input" type="number" step="any" placeholder="min" />
            <input id="f-max-pl_rade" class="exo-input" type="number" step="any" placeholder="max" />
          </div>
          <div><div class="exo-filter-label">Radius (RJ)</div>
            <input id="f-min-pl_radj" class="exo-input" type="number" step="any" placeholder="min" />
            <input id="f-max-pl_radj" class="exo-input" type="number" step="any" placeholder="max" />
          </div>
          <div><div class="exo-filter-label">Period (days)</div>
            <input id="f-min-pl_orbper" class="exo-input" type="number" step="any" placeholder="min" />
            <input id="f-max-pl_orbper" class="exo-input" type="number" step="any" placeholder="max" />
          </div>
          <div><div class="exo-filter-label">Stellar Age (Gyr)</div>
            <input id="f-min-st_age" class="exo-input" type="number" step="any" placeholder="min" />
            <input id="f-max-st_age" class="exo-input" type="number" step="any" placeholder="max" />
          </div>
          <div><div class="exo-filter-label">Stellar Radius (R☉)</div>
            <input id="f-min-st_rad" class="exo-input" type="number" step="any" placeholder="min" />
            <input id="f-max-st_rad" class="exo-input" type="number" step="any" placeholder="max" />
          </div>
          <div><div class="exo-filter-label">Equilibrium T (K)</div>
            <input id="f-min-pl_eqt" class="exo-input" type="number" step="any" placeholder="min" />
            <input id="f-max-pl_eqt" class="exo-input" type="number" step="any" placeholder="max" />
          </div>
        </div>
        <div class="exo-row gap">
          <button id="applyFilters" class="exo-btn">Update</button>
          <button id="clearFilters" class="exo-btn ghost">Clear</button>
        </div>
      </div>

      <div class="exo-card">
        <h2>Highlights</h2>
        <label class="exo-check"><input id="highlightJWSTObs" type="checkbox" checked/> JWST – Observed</label>
        <label class="exo-check"><input id="highlightJWSTPlan" type="checkbox" checked/> JWST – Planned</label>
        <label class="exo-check"><input id="highlightHST" type="checkbox" checked/> HST – Atmospheric</label>
        <div class="exo-note">JWST Observed = <b>Executed</b>. JWST Planned = Scheduled / Implementation / Flight Ready / Inactive / On Hold.</div>
      </div>
    </div>

    <aside class="exo-card exo-presets">
      <h2>Presets & Metrics</h2>
      <div class="exo-chiprow">
        <span class="exo-chip sep">Kempton+18 bins</span>
        <button class="exo-chip" data-preset="k18-rocky">&lt;1.5 R⊕</button>
        <button class="exo-chip" data-preset="k18-small">1.5–2.75 R⊕</button>
        <button class="exo-chip" data-preset="k18-subn">2.75–4.0 R⊕</button>
        <button class="exo-chip" data-preset="k18-giant">&gt;4 R⊕</button>
      </div>
      <div class="exo-chiprow">
        <span class="exo-chip sep">Popular</span>
        <button class="exo-chip" data-preset="hotjup">Hot Jupiters</button>
        <button class="exo-chip" data-preset="subnep">Sub‑Neptunes</button>
      </div>
      <hr/>
      <div class="exo-chiprow">
        <label class="exo-check"><input id="useTSM" type="checkbox"/> Size by TSM</label>
        <label class="exo-check"><input id="useESM" type="checkbox"/> Size by ESM</label>
      </div>
      <div class="exo-note">
        Sources: 
        <a href="https://exoplanetarchive.ipac.caltech.edu/" target="_blank" rel="noopener">NASA Exoplanet Archive</a> (population), 
        <a href="https://www.stsci.edu/~nnikolov/TrExoLiSTS/JWST/trexolists.html" target="_blank" rel="noopener">TrExoLiSTS – JWST</a>, 
        <a href="https://www.stsci.edu/~WFC3/trexolists/trexolists.html" target="_blank" rel="noopener">TrExoLiSTS – HST</a>.<br/>
        TSM (transmission) & ESM (emission) per Kempton+2018. When enabled, marker size ∝ √metric (clamped).<br/>
        Threshold guide: TSM &gt; 10 (R&lt;1.5R⊕), TSM &gt; 90 (1.5–10R⊕), ESM &gt; 7.5 (terrestrial).<br/>
        If TSM/ESM sizing is ON, JWST/HST points follow the metric size (no extra ×2).
      </div>
    </aside>
  </div>

  <div class="exo-main">
    <div id="plot" class="exo-plot"></div>
    <aside class="exo-card">
      <h3>Legend</h3>
      <ul class="exo-legend">
        <li><span class="dot" style="border:2px solid #9CA3AF; background:transparent;"></span> Population w/ CK17 mass (plus)</li>
        <li><span class="dot pop"></span> Population</li>
        <li><span class="dot jwstobs diamond"></span> JWST – Observed (diamond)</li>
        <li><span class="dot jwstplan diamond"></span> JWST – Planned (diamond)</li>
        <li><span class="dot hst square"></span> HST – Atmospheric (square)</li>
      </ul>
      <div id="counts" class="exo-note">—</div>
      <hr/>
      <div class="exo-note">
        CSVs: <code>/assets/data/pscomppars_recent.csv</code>, <code>/assets/data/jwst_trexolists_extended.csv</code>, <code>/assets/data/HST_Trexolist.csv</code>
      </div>
      <div id="status" class="exo-note">Loading population CSV…</div>
    </aside>
  </div>

  <details class="exo-card">
    <summary>Show current settings</summary>
    <pre id="endpoints" class="exo-code"></pre>
  </details>
</div>

<!-- libs -->
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
:root {
  --mpurple: #9370DB;   /* JWST observed */
  --orange: #E69F00;    /* JWST planned */
  --green: #10B981;     /* HST */
  --muted: #6b7280;
  --bg: #f6f4fb;
}
body { background: var(--bg); }
.exo-container { display: grid; gap: 1rem; }
.exo-topbar { display:grid; grid-template-columns: 1fr 320px; gap: 1rem; }
.exo-controls { display: grid; grid-template-columns: repeat(3,minmax(0,1fr)); gap: 1rem; }
.exo-main { display: grid; grid-template-columns: 1fr 320px; gap: 1rem; }
.exo-card { background: #fff; border: 1px solid #e5e7eb; border-radius: 16px; padding: 1rem; box-shadow: 0 1px 2px rgba(0,0,0,.05); }
.exo-plot { height: 72vh; border: 1px solid #e5e7eb; border-radius: 16px; }
.exo-input { width: 100%; padding: .45rem .6rem; border: 1px solid #d1d5db; border-radius: 10px; }
.exo-btn { padding: .55rem .8rem; border-radius: 10px; border: none; color: #fff; background: var(--mpurple); cursor: pointer; }
.exo-btn.ghost { background: transparent; color: var(--mpurple); border: 1px solid var(--mpurple); }
.exo-btn:hover { opacity:.95; }
.exo-check { display:inline-flex; align-items:center; gap:.4rem; margin-right:.6rem; }
.exo-legend { list-style:none; padding:0; margin:.5rem 0; }
.dot { display:inline-block; width:10px; height:10px; border-radius:999px; margin-right:.4rem; }
.dot.pop { background:#9CA3AF; opacity:.8; }
.dot.jwstobs { background:#9370DB; }
.dot.jwstplan { background:#E69F00; }
.dot.hst { background:#10B981; }
.dot.diamond { clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); }
.dot.square { border-radius: 3px; }
.exo-note { color: var(--muted); font-size: .85rem; }
.exo-code { background:#f3f4f6; padding:.6rem; border-radius:12px; }
.exo-grid2 { display:grid; grid-template-columns: repeat(2,minmax(0,1fr)); gap:.6rem; }
.exo-grid4 { display:grid; grid-template-columns: repeat(4,minmax(0,1fr)); gap:.6rem; }
.exo-row.gap { display:flex; gap:.6rem; margin-top:.5rem; }
.exo-presets .exo-chiprow { display:flex; flex-wrap:wrap; align-items:center; gap:.4rem; margin-bottom:.4rem; }
.exo-chip { background:#f3f0ff; border:1px solid #e1d7ff; color:#4b3a8f; padding:.25rem .5rem; border-radius:999px; font-size:.85rem; cursor:pointer; }
.exo-chip.sep { background:transparent; border:0; color:#6b7280; cursor:default; font-weight:600; }
@media (max-width: 1100px){
  .exo-controls{ grid-template-columns: 1fr; }
  .exo-topbar{ grid-template-columns: 1fr; }
  .exo-main{ grid-template-columns: 1fr; }
}
</style>

<script>
// ---------------------------
// Config & columns
// ---------------------------
const POP_CSV = '/assets/data/pscomppars_recent.csv';
const JWST_CSV = '/assets/data/jwst_trexolists_extended.csv';
const HST_CSV = '/assets/data/HST_Trexolist.csv';

const PARAMS = {
  'Best Planet Mass (M_⊕)': d => num(d.pl_bmasse),
  'Best Planet Mass (M_J)': d => num(d.pl_bmassj),
  'Planet Radius (R_⊕)': d => num(d.pl_rade),
  'Planet Radius (R_J)': d => num(d.pl_radj),
  'Orbital Period (days)': d => num(d.pl_orbper),
  'Stellar Age (Gyr)': d => num(d.st_age),
  'Stellar Radius (R_☉)': d => num(d.st_rad),
  'Equilibrium Temperature (K)': d => num(d.pl_eqt),
};

const PRESETS = {
  'k18-rocky': { pl_rade: [null, 1.5] },
  'k18-small': { pl_rade: [1.5, 2.75] },
  'k18-subn':  { pl_rade: [2.75, 4.0] },
  'k18-giant': { pl_rade: [4.0, null] },
  'hotjup': { pl_rade: [8, null], pl_eqt: [1000, null] },
  'subnep': { pl_rade: [2, 4] },
};

// ---------------------------
// Utilities
// ---------------------------
// ---------------------------
// CK17 mass-from-radius (Forecaster centerline)
// ---------------------------
const EARTH_TO_JUP_MASS = 1/317.83;
const JUP_TO_EARTH_MASS = 317.83;
const RJ_TO_RE = 11.209;

function ckMassFromRadius_Re(radius_Re){
  const R = +radius_Re;
  if(!isFinite(R) || R<=0) return null;
  // Degeneracy band where inverse is non-unique
  if(R >= 11.1 && R <= 14.3) return null;
  const logR = Math.log10(R);
  let C, S;
  if(R < 1.23){ C = 0.00346; S = 0.2790; }        // Terran
  else if(R < 11.1){ C = -0.0925; S = 0.589; }    // Neptunian
  else { C = -2.85; S = 0.881; }                  // Jovian (R >= 14.3)
  const logM = (logR - C)/S;
  const Mearth = Math.pow(10, logM);
  return (isFinite(Mearth) && Mearth>0) ? Mearth : null;
}
function ckMassFromRadius_Rj(radius_Rj){
  const Rj = +radius_Rj;
  if(!isFinite(Rj) || Rj<=0) return null;
  const Re = Rj * RJ_TO_RE;
  const Mearth = ckMassFromRadius_Re(Re);
  return (Mearth==null) ? null : Mearth * EARTH_TO_JUP_MASS;
}

// Unified getters that prefer measured mass; fall back to CK17 if enabled
function getMassJ(p, ckEnabled){
  let mj = (p.pl_bmassj!=null && isFinite(+p.pl_bmassj)) ? +p.pl_bmassj :
           (p.pl_bmasse!=null && isFinite(+p.pl_bmasse)) ? (+p.pl_bmasse)*EARTH_TO_JUP_MASS : null;
  let usedCK = false;
  if(mj==null && ckEnabled){
    if(p.pl_rade!=null && isFinite(+p.pl_rade)){
      const mE = ckMassFromRadius_Re(+p.pl_rade);
      if(mE!=null){ mj = mE*EARTH_TO_JUP_MASS; usedCK = true; }
    }else if(p.pl_radj!=null && isFinite(+p.pl_radj)){
      const mJ = ckMassFromRadius_Rj(+p.pl_radj);
      if(mJ!=null){ mj = mJ; usedCK = true; }
    }
  }
  return {value: (isFinite(mj)? mj : null), usedCK};
}
function getMassE(p, ckEnabled){
  let me = (p.pl_bmasse!=null && isFinite(+p.pl_bmasse)) ? +p.pl_bmasse :
           (p.pl_bmassj!=null && isFinite(+p.pl_bmassj)) ? (+p.pl_bmassj)*JUP_TO_EARTH_MASS : null;
  let usedCK = false;
  if(me==null && ckEnabled){
    if(p.pl_rade!=null && isFinite(+p.pl_rade)){
      const mE = ckMassFromRadius_Re(+p.pl_rade);
      if(mE!=null){ me = mE; usedCK = true; }
    }else if(p.pl_radj!=null && isFinite(+p.pl_radj)){
      const mJ = ckMassFromRadius_Rj(+p.pl_radj);
      if(mJ!=null){ me = mJ*JUP_TO_EARTH_MASS; usedCK = true; }
    }
  }
  return {value: (isFinite(me)? me : null), usedCK};
}

function valueForKey(p, key, ckEnabled){
  switch(key){
    case 'Best Planet Mass (M_J)': return getMassJ(p, ckEnabled).value;
    case 'Best Planet Mass (M_⊕)': return getMassE(p, ckEnabled).value;
    default: return PARAMS[key](p);
  }
}
function usedCKForKey(p, key, ckEnabled){
  if(!ckEnabled) return false;
  switch(key){
    case 'Best Planet Mass (M_J)': return getMassJ(p, true).usedCK;
    case 'Best Planet Mass (M_⊕)': return getMassE(p, true).usedCK;
    default: return false;
  }
}

// Helper: identify if axis is one of the mass axes
function isMassAxis(key){
  return key === 'Best Planet Mass (M_J)' || key === 'Best Planet Mass (M_⊕)';
}

const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const num = v => (v==null || v==='' ? null : (isFinite(+v)? +v : null));
const canon = s => (s||'').toString().trim().toLowerCase().replace(/\u2212/g,'-').replace(/[\s]+/g,' ');

function csvParseLoose(text){
  const cleaned = text.split(/\n/).filter(l => !/^\s*#/.test(l)).join('\n');
  return d3.csvParse(cleaned);
}
function keyVariants(host, letter){
  const h = (host||'').toString().trim().replace(/\u2212/g,'-');
  const L = (letter||'').toString().trim().replace(/\u2212/g,'-');
  const full = `${h} ${L}`.toLowerCase();
  return new Set([full, full.replace(/\s+/g,''), full.replace(/-/g,' '), full.replace(/\s+/g,'-')]);
}
function nameVariantsFromPlName(plname){
  const nm = canon((plname||'').toString().replace(/\u2212/g,'-'));
  return new Set([nm, nm.replace(/\s+/g,''), nm.replace(/-/g,' '), nm.replace(/\s+/g,'-')]);
}
function hostFromPlName(plname){
  const s = canon((plname||'').toString().replace(/\u2212/g,'-'));
  return s.replace(/[-\s]*[bcdefgh]$/,'').trim();
}
function variantSetForHost(name){
  const nm = canon(name);
  return new Set([ nm, nm.replace(/\s+/g,''), nm.replace(/-/g,' '), nm.replace(/\s+/g,'-') ]);
}

// ---------------------------
// State
// ---------------------------
const state = { all: [], rows: [],
  jwstObserved: new Set(), jwstPlanned: new Set(),
  hstHostnames: new Set(),
  hostVariantSet: new Set(),
  filters: {}, sizing: { tsm:false, esm:false }
};

// ---------------------------
// Loaders
// ---------------------------
async function loadCSV(url){
  const res = await fetch(url, {mode:'cors'});
  if(!res.ok) throw new Error('Failed to fetch '+url+' '+res.status);
  const txt = await res.text();
  return csvParseLoose(txt);
}
async function loadPopulation(){
  const rows = await loadCSV(POP_CSV);
  const numCols = ['pl_bmasse','pl_bmassj','pl_rade','pl_radj','pl_orbper','st_age','st_rad','pl_eqt','st_teff','sy_jmag','sy_kmag','tran_flag'];
  for (const r of rows) {
    for (const k of numCols) {
      if (r[k] !== undefined) {
        const val = num(r[k]);
        if (val !== null) r[k] = val;
      }
    }
  }
  const variants = new Set();
  for (const r of rows) {
    if (r.hostname) variantSetForHost(r.hostname).forEach(v => variants.add(v));
    if (r.pl_name) variantSetForHost(hostFromPlName(r.pl_name)).forEach(v => variants.add(v));
  }
  state.hostVariantSet = variants;
  return rows;
}
async function loadJWST(){
  try{
    const rows = await loadCSV(JWST_CSV);
    const obs = new Set(), plan = new Set();
    const PLANNED = new Set(['Scheduled','Implementation','Flight Ready','Inactive','On Hold','On Hold (Inactive)']);
    for(const r of rows){
      const host =((r.hostname_nn) != null ? (r.hostname_nn) : (r['Star   name'] ?? r['Star name'] ?? r['Star']));
      const letter =((r.letter_nn) != null ? (r.letter_nn) : (r['Planet   letter'] ?? r['Planet letter'] ?? r['Planet']));
      const status = (r.Status || '').trim();
      if(!host || !letter) continue;
      const keys = keyVariants(host, letter);
      if(status === 'Executed'){ keys.forEach(k=>obs.add(k)); }
      else if(PLANNED.has(status)){ keys.forEach(k=>plan.add(k)); }
    }
    state.jwstObserved = obs; state.jwstPlanned = plan;
    const s = document.getElementById('status');
    if(s) s.textContent = `${s.textContent} | JWST loaded (Obs: ${obs.size}, Plan: ${plan.size})`;
    refresh();
  }catch(err){ console.warn('JWST CSV load failed (non-fatal):', err); }
}
async function loadHST(){
  try{
    const rows = await loadCSV(HST_CSV);
    const names = new Set();

    // Try to discover a reasonable "target" column (case-insensitive)
    const cols = rows.columns || Object.keys(rows[0] || {});
    let targetCol = cols.find(c => /target\s*name/i.test(c)) ||
                    cols.find(c => /^target$/i.test(c)) ||
                    cols.find(c => /host/i.test(c)) ||
                    cols.find(c => /star/i.test(c)) ||
                    'Target Name';

    for(const r of rows){
      const cell = r[targetCol];
      if(!cell) continue;
      // Split on commas/semicolons/slashes or multiple spaces
      const parts = cell.split(/[;,\/]|\s{2,}|\s+\/\s+/).map(s => s.trim()).filter(Boolean);
      if(parts.length === 0) parts.push(cell);

      for(const raw of parts){
        let h = raw;
        // Remove any annotation blocks
        h = h.replace(/\(.*?\)|\[.*?\]/g, '').trim();
        const variants = variantSetForHost(h);
        for(const v of variants){ if(state.hostVariantSet.has(v)) names.add(v); }
      }
    }
    state.hstHostnames = names;
    const s = document.getElementById('status');
    if(s) s.textContent = `${s.textContent} | HST loaded (${names.size})`;
    refresh();
  }catch(err){ console.warn('HST CSV load failed (non-fatal):', err); }
}

// ---------------------------
// TSM / ESM helpers (relative)
// ---------------------------
function tsmScaleFactor(rpRe){
  if(rpRe==null) return null;
  if(rpRe < 1.5) return 0.190;
  if(rpRe < 2.75) return 1.26;
  if(rpRe < 4.0) return 1.28;
  return 1.15;
}
function computeTSM(row){
  const Rp = num(row.pl_rade), Mp = num(row.pl_bmasse), Rs = num(row.st_rad), Teq = num(row.pl_eqt), J = num(row.sy_jmag);
  if(Rp==null||Mp==null||Mp<=0||Rs==null||Teq==null||J==null) return null;
  const scale = tsmScaleFactor(Rp); if(scale==null) return null;
  const val = scale * ((Rp**3)*Teq / (Mp*(Rs**2))) * Math.pow(10, -J/5);
  return (isFinite(val)? val : null);
}
function planckProxy(T){ const t=num(T); return (t==null||t<=0)? null : Math.pow(t,4); }
function computeESM(row){
  const Rp = num(row.pl_rade), Rs = num(row.st_rad), Teq = num(row.pl_eqt), Ts = num(row.st_teff), K = num(row.sy_kmag);
  if(Rp==null||Rs==null||Teq==null||Ts==null||K==null) return null;
  const Tday = 1.1*Teq;
  const pr = planckProxy(Tday), ps = planckProxy(Ts); if(pr==null||ps==null) return null;
  const val = 4.29e6 * (pr/ps) * ((Rp/109.1)/Rs)**2 * Math.pow(10, -K/5);
  return (isFinite(val)? val : null);
}

// ---------------------------
// UI defaults
// ---------------------------
function populateDropdowns(){
  const xSel = document.getElementById('xSelect');
  const ySel = document.getElementById('ySelect');
  const opts = Object.keys(PARAMS).map(l=>`<option>${l}</option>`).join('');
  xSel.innerHTML = ySel.innerHTML = opts;

  // Defaults requested:
  xSel.value = 'Best Planet Mass (M_J)';  // X-axis: MJ
  ySel.value = 'Planet Radius (R_J)';     // Y-axis: RJ
  document.getElementById('xLog').checked = true;  // log X
  document.getElementById('yLog').checked = true;  // log Y
  document.getElementById('onlyTransiting').checked = true; // transiting only
  // JWST toggles are already checked in the HTML
}

function setFilter(id, val){ const el=document.getElementById(id); el.value = (val==null? '' : val); }

function applyFiltersAndRefresh(){
  const keys = ['pl_bmasse','pl_bmassj','pl_rade','pl_radj','pl_orbper','st_age','st_rad','pl_eqt'];
  const f = {};
  for(const k of keys){
    const minv = num(document.getElementById('f-min-'+k).value);
    const maxv = num(document.getElementById('f-max-'+k).value);
    if(minv!=null || maxv!=null) f[k] = [minv, maxv];
  }
  state.filters = f;
  filterRows();
  refresh();
}
function clearFilters(){ state.filters={}; $$('.exo-filters input').forEach(i=>i.value=''); filterRows(true); refresh(); }

function filterRows(){
  const onlyTransiting = document.getElementById('onlyTransiting').checked;
  const f = state.filters;
  state.rows = state.all.filter(r => {
    if (onlyTransiting && r.tran_flag !== 1) return false;
    for(const [k,[mn,mx]] of Object.entries(f)){
      const v = num(r[k]);
      if(v==null) return false;
      if(mn!=null && v<mn) return false;
      if(mx!=null && v>mx) return false;
    }
    return true;
  });
}


function buildTraces(){
  const xKey = document.getElementById('xSelect').value;
  const yKey = document.getElementById('ySelect').value;
  const colorByTeq = document.getElementById('colorTemp').checked;
  const showObs = document.getElementById('highlightJWSTObs').checked;
  const showPlan = document.getElementById('highlightJWSTPlan').checked;
  const showHST = document.getElementById('highlightHST').checked;
  const showLabels = document.getElementById('showLabels').checked;
  const useTSM = document.getElementById('useTSM').checked;
  const useESM = document.getElementById('useESM').checked;
  const ckEnabled = document.getElementById('ckPredict') ? document.getElementById('ckPredict').checked : false;

  const massAxisUsed = isMassAxis(xKey) || isMassAxis(yKey);

  const pop = [], obs = [], plan = [], hst = [];
  const labelsPop=[], labelsObs=[], labelsPlan=[], labelsHst=[];
  const popSizes=[], obsSizes=[], planSizes=[], hstSizes=[];
  const popSymbols=[], popOpacities=[];

  for(const p of state.rows){
    // Default rule: if mass axis is used and CK is OFF, exclude M-R provenance (already mass-radius inferred)
    if(!ckEnabled && massAxisUsed){
      const prov = (p.pl_bmassprov || '').toLowerCase();
      if(prov.includes('m-r relationship')) continue;
    }

    const x = valueForKey(p, xKey, ckEnabled);
    const y = valueForKey(p, yKey, ckEnabled);
    if(x==null || y==null) continue;

    const variants = nameVariantsFromPlName(p.pl_name);
    const isObs = [...variants].some(v => state.jwstObserved.has(v));
    const isPlan = !isObs && [...variants].some(v => state.jwstPlanned.has(v));

    const hostKey = variantSetForHost(p.hostname||'');
    let isHST = false;
    for(const v of hostKey){ if(state.hstHostnames.has(v)){ isHST=true; break; } }

    let sizeVal = 6;
    if(useTSM || useESM){
      const metric = useTSM ? computeTSM(p) : computeESM(p);
      if(metric!=null && isFinite(metric)) sizeVal = Math.max(6, Math.min(24, Math.sqrt(metric)));
    }

    if(isObs){
      obs.push({x,y,teq:p.pl_eqt, name:p.pl_name||''});
      obsSizes.push(sizeVal);
      if(showLabels) labelsObs.push(p.pl_name||'');
    } else if(isPlan){
      plan.push({x,y,teq:p.pl_eqt, name:p.pl_name||''});
      planSizes.push(sizeVal);
      if(showLabels) labelsPlan.push(p.pl_name||'');
    } else if(isHST && showHST){
      hst.push({x,y,teq:p.pl_eqt, name:p.pl_name||''});
      hstSizes.push(sizeVal);
      if(showLabels) labelsHst.push(p.pl_name||'');
    } else {
      pop.push({x,y,teq:p.pl_eqt, name:p.pl_name||''});
      popSizes.push((useTSM||useESM)? sizeVal : 6);
      const usedCK = usedCKForKey(p, xKey, ckEnabled) || usedCKForKey(p, yKey, ckEnabled);
      // Use PLUS SIGN marker for CK-predicted any-axis point
      popSymbols.push( usedCK ? 'cross' : 'circle' );
      popOpacities.push( usedCK ? 0.85 : 0.85 );
      if(showLabels) labelsPop.push(p.pl_name||'');
    }
  }

  const baseType = showLabels ? 'scatter' : 'scattergl';
  const baseMode = showLabels ? 'markers+text' : 'markers';

  const traces = [];
  const hoverCommon = {hovertemplate: '%{hovertext}<extra></extra>'};

  if(colorByTeq){
    traces.push(Object.assign({
      name: 'Population (Teq)', type: baseType, mode: baseMode,
      x: pop.map(d=>d.x), y: pop.map(d=>d.y), hovertext: pop.map(d=>d.name),
      marker: { size: popSizes, opacity: popOpacities, symbol: popSymbols,
                color: pop.map(d=>((d.teq) != null ? (d.teq) : (NaN))), colorscale:'Viridis', showscale:true, colorbar:{title:'Teq (K)'} },
      text: (showLabels ? labelsPop : []), textposition: 'top center'
    }, hoverCommon));
  } else {
    traces.push(Object.assign({
      name: 'Population', type: baseType, mode: baseMode,
      x: pop.map(d=>d.x), y: pop.map(d=>d.y), hovertext: pop.map(d=>d.name),
      marker:{ size: popSizes, opacity: popOpacities, symbol: popSymbols, color:'#9CA3AF' },
      text: (showLabels ? labelsPop : []), textposition: 'top center'
    }, hoverCommon));
  }

  if(showPlan){
    traces.push(Object.assign({
      name: 'JWST – Planned', type: baseType, mode: baseMode,
      x: plan.map(d=>d.x), y: plan.map(d=>d.y), hovertext: plan.map(d=>d.name),
      marker:{ symbol:'diamond', size: (useTSM||useESM) ? planSizes : 12, opacity:.95, color:'#E69F00' },
      text: (showLabels ? labelsPlan : []), textposition: 'top center'
    }, hoverCommon));
  }
  if(showObs){
    traces.push(Object.assign({
      name: 'JWST – Observed', type: baseType, mode: baseMode,
      x: obs.map(d=>d.x), y: obs.map(d=>d.y), hovertext: obs.map(d=>d.name),
      marker:{ symbol:'diamond', size: (useTSM||useESM) ? obsSizes : 12, opacity:.95, color:'#9370DB' },
      text: (showLabels ? labelsObs : []), textposition: 'top center'
    }, hoverCommon));
  }
  if(showHST){
    traces.push(Object.assign({
      name: 'HST – Atmospheric', type: baseType, mode: baseMode,
      x: hst.map(d=>d.x), y: hst.map(d=>d.y), hovertext: hst.map(d=>d.name),
      marker:{ symbol:'square', size: (useTSM||useESM) ? hstSizes : 10, opacity:.95, color:'#10B981' },
      text: (showLabels ? labelsHst : []), textposition: 'top center'
    }, hoverCommon));
  }
  return traces;
}


function layoutForAxes(){
  var xKey = document.getElementById('xSelect').value;
  var yKey = document.getElementById('ySelect').value;
  var xIsLog = document.getElementById('xLog').checked;
  var yIsLog = document.getElementById('yLog').checked;
  var xaxis = { title: xKey, type: xIsLog ? 'log' : 'linear', zeroline:false, exponentformat:'E', showexponent:'all' };
  var yaxis = { title: yKey, type: yIsLog ? 'log' : 'linear', zeroline:false, exponentformat:'E', showexponent:'all' };
  if (!xIsLog) xaxis.tickformat = '.3e';
  if (!yIsLog) yaxis.tickformat = '.3e';
  return {
    margin:{l:60,r:10,t:18,b:50},
    xaxis:xaxis,
    yaxis:yaxis,
    showlegend:false
  };
}

function refresh(){
  const traces = buildTraces();
  Plotly.react('plot', traces, layoutForAxes(), {responsive:true, displaylogo:false});
  const shown = traces.reduce((acc,t)=> acc + ((t.x && t.x.length)||0), 0);
  document.getElementById('counts').textContent = `${shown.toLocaleString()} points shown (within ${state.rows.length.toLocaleString()} filtered rows).`;
  summarizeInputs();
}

function hookUI(){
  ['xSelect','ySelect','xLog','yLog','colorTemp','showLabels','onlyTransiting','highlightJWSTObs','highlightJWSTPlan','highlightHST','useTSM','useESM','ckPredict']
    .forEach(id => document.getElementById(id).addEventListener('change', () => { filterRows(); refresh(); }));
  document.getElementById('applyFilters').addEventListener('click', applyFiltersAndRefresh);
  document.getElementById('clearFilters').addEventListener('click', () => clearFilters());
  document.querySelectorAll('.exo-chip[data-preset]').forEach(btn => {
    btn.addEventListener('click', () => {
      const p = btn.getAttribute('data-preset');
      const def = PRESETS[p]||{};
      $$('.exo-filters input').forEach(i=> i.value='');
      for(const [k,[mn,mx]] of Object.entries(def)){
        const el1=document.getElementById('f-min-'+k), el2=document.getElementById('f-max-'+k);
        if(el1) el1.value=(mn != null ? mn : ''); if(el2) el2.value=(mx != null ? mx : '');
      }
    });
  });
}

function summarizeInputs(){
  const s = [];
  s.push('X: '+document.getElementById('xSelect').value);
  s.push('Y: '+document.getElementById('ySelect').value);
  s.push('Filters: '+JSON.stringify(state.filters));
  s.push('TSM sizing: '+(document.getElementById('useTSM').checked?'on':'off'));
  s.push('ESM sizing: '+(document.getElementById('useESM').checked?'on':'off'));
  document.getElementById('endpoints').textContent = s.join('\n');
}

// ---------------------------
// Boot
// ---------------------------
(async function init(){
  try{
    populateDropdowns();
    hookUI();

    const popRows = await loadPopulation();
    state.all = popRows.slice();

    // Apply defaults (transiting only) before first render
    filterRows();
    document.getElementById('status').textContent = `Loaded population CSV (rows: ${state.all.length.toLocaleString()})`;
    refresh();

    // Non-blocking loads
    loadJWST();
    loadHST();
  }catch(err){
    console.error(err);
    document.getElementById('status').textContent = 'Failed to load population CSV.';
  }
})();
</script>
